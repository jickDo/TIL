# 자바의 컬렉션 프레임워크

---

자바의 컬렉션 프레임워크란 자료구조에서 배우는 여러가지 형태의 데이터를 저장하는 알고리즘을 구조화 하여 구현해둔 클래스이다. 쉽게 생각하면
자료구조를 모듈화 하여 사용하기 쉽게 만들어둔 자바 내부 라이브러리 인것이다.

자바의 컬렉션은 크게 두가지 계층 구조로 나눌수 있는데 첫번째 사진처럼 **Collection** 을 상속받는 **List**, **Queue**,
**Set** 인터페이스 구조와 아래 사진처럼 **Map**인터페이스를 가지는 구조로 나눌수가 있다.

<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210521/Collection-Framework-1.png">
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210611/Collection-Framework-2.png">

[사진 출처](https://www.geeksforgeeks.org/how-to-learn-java-collections-a-complete-guide/)

<br><br>

## List 

---

List는 자신을 구현한 4가지의 구현체의 인터페이스 이다. List.java의 내용을 토대로 List의 특징을 요약하면

1. 순서가 있다.
2. 중복을 허용한다.
3. 인덱스로 접근을 한다.

라는 특징을 가지고있다.


<br><br>

### ArrayList

---

List 인터페이스에서 리사이징-어레이를 구현한 형태이다. 이 클래스는 ArrayList.java 소스 파일에서 말하길, List를 구현한 것 외에도
리스트 저장을 위한 내부적으로 사용되는 배열의 크기를 조작한다.

또한 **동기화**가 되지않는다는 특징이있다.
또한, ArrayList에서 시행되는 **size, isEmpty, get, set, iterator, and listIterator** 연산은 상수 시간에서
시행된다. 또한 ArrayList에는 용량이 있으며, 항상 목록크기보다 최소한으로 큰 용량을 가지며 목록이 용량보다 커질경우 자동으로 용량이 증가한다는 특징이 있다고 한다.

이를 요약하자면,

1. List 인터페이스를 구현한 구현체
2. List 인터페이스에서 리사이징 기능이 추가됨
3. 동기화가 되지 않는다.
4. 순차적인 접근법에 따라 대게 상수 시간의 연산속도를 가진다.

<br>

````java
List<String> arrayList = new ArrayList<>();

arrayList.add("어레이 리스트 입니다");   //String 문자열을 추가합니다
arrayList.add(0,"이렇게 도 가능합니다"); //add의 오버로드 형태입니다.
arrayList.set(0,"update 입니다");    //특정 인덱스의 값을 변화시킵니다.
arrayList.get(0);                  //인덱스를 기준으로 가져옵니다.
arrayList.size();                  //현재 어레이 리스트의 크기를 리턴합니다.
````

<br><br>

### Vector

---

Vector는 내부구조가 ArrayList와 거의 비슷하지만 동기화 된다는 특징이 있다. 자바 2 플랫폼 v1.2부터 벡터는 리스트 인터페이스를 
구현하기 위해 개조되어 컬렉션 프레임워크가 되었다고 한다. Vector 클래스 내부 설명에 따르면 특수하게 Thread-Safe 환경이 아니라면
ArrayList를 사용하는 것을 권장한다.

<br>

````java
List<Integer> vector = new Vector<>();

vector.add(0);    //0을 추가합니다.
vector.add(20);   //다음 인덱스에 20을 추가합니다
vector.set(1,30); //1번 인덱스의 값을 30으로 교체합니다.
vector.size();    //사이즈를 리턴합니다.
vector.get(1);    //1번 인덱스의 값을 가져옵니다.
````

<br><br>

### LinkedList

---

LinkedList의 각 요소들은 다음 요소들의 참조값을 가지고 있다. 그러한 특징 때문에 데이터를 삭제 혹은 추가를 하게 되는 경우 이전 
ArrayList처럼 순환을 돌며 시행하지 않아도 되기 때문에 삭제나 추가에 강한 성능을 보인다.

하지만 데이터가 많아질 수록 무거워 지는 특성을
지녔다고 한다. 또한 LinkedList는 List와 Deque 인터페이스들을 이중으로 구현한다는 특징을 하지고 있다.

<br>

```java
List<String> linkedList = new LinkedList<>();
      
linkedList.add("20");   //20을 추가합니다
linkedList.add("30");   //30을 추가합니다
linkedList.size();      //현제 사이즈를 리턴합니다.
linkedList.set(1,"40"); //인덱스 1의 위치에 40으로 값을 교체합니다.
linkedList.get(1);      //인덱스 1의 값을 리턴합니다.
```

<br><br>

### Stack

---

마지막으로 자료구조에서 자주보던 Stack이다. Stack또한 자바의 컬렉션 프레임워크에서 구현이 되어있으며, 기존 특성처럼 LIFO(Last In First Out)의
특징을 가지고 있다. 기존 Vector을 상속받기 때문에 자연스럽게 안쓰인다고 한다. 더군다나 더욱 완벽한 LIFO 구조로 Deque가 존재하기 때문에
Deque를 사용하라고 권고 한다.

```java
Stack<Integer> stack = new Stack<>();  //stack에만 선언된 기능을 사용하기 위해선 Stack 타입 변수로 선언

stack.add(20);    //20을추가
stack.push(30);   //30을 추가 
stack.set(1,50);  //1번 인덱스값을 50으로 변환
stack.peek();     //최상위 값출력 스택 기준 최상위는 가장 마지막에 입력된 값 여기서는 50
stack.pop();      //최상위 값 제거
stack.peek();     //최상위 값을 제거하고 최상위 값을 출력했을때 20이 나온다.
```

<br><br>

## Queue

---

하위에 Deque인터페이스와 PriorityQueue를 가지는, 인터페이스이다. Queue의 특징으로는
1. Queue 는 Stack 과 비교되는 자료형 구조이다.
2.  FIFO(First-In-First-Out)구조이며, 설명대로 처음 들어간 값이 처음 나오는
    터널과 같은 구조이다.
3. 자바의 Stack은 구현체지만 Queue는 인터페이스이니 사용에 조심해야한다.

라는 특징을 가지고 있다.

<br><br>


### PriorityQueue

---






