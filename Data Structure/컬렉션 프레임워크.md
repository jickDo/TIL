# 자바의 컬렉션 프레임워크

---

자바의 컬렉션 프레임워크란 자료구조에서 배우는 여러가지 형태의 데이터를 저장하는 알고리즘을 구조화 하여 구현해둔 클래스이다. 쉽게 생각하면
자료구조를 모듈화 하여 사용하기 쉽게 만들어둔 자바 내부 라이브러리 인것이다.

자바의 컬렉션은 크게 두가지 계층 구조로 나눌수 있는데 첫번째 사진처럼 **Collection** 을 상속받는 **List**, **Queue**,
**Set** 인터페이스 구조와 아래 사진처럼 **Map**인터페이스를 가지는 구조로 나눌수가 있다.

<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210521/Collection-Framework-1.png">
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210611/Collection-Framework-2.png">

[사진 출처](https://www.geeksforgeeks.org/how-to-learn-java-collections-a-complete-guide/)

<br><br>

## List 

---

List는 자신을 구현한 4가지의 구현체의 인터페이스 이다. List.java의 내용을 토대로 List의 특징을 요약하면

1. 순서가 있다.
2. 중복을 허용한다.
3. 인덱스로 접근을 한다.

라는 특징을 가지고있다.


<br><br>

### ArrayList

---

List 인터페이스에서 리사이징-어레이를 구현한 형태이다. 이 클래스는 ArrayList.java 소스 파일에서 말하길, List를 구현한 것 외에도
리스트 저장을 위한 내부적으로 사용되는 배열의 크기를 조작한다.

또한 **동기화**가 되지않는다는 특징이있다.
또한, ArrayList에서 시행되는 **size, isEmpty, get, set, iterator, and listIterator** 연산은 상수 시간에서
시행된다. 또한 ArrayList에는 용량이 있으며, 항상 목록크기보다 최소한으로 큰 용량을 가지며 목록이 용량보다 커질경우 자동으로 용량이 증가한다는 특징이 있다고 합니다.

이를 요약하자면,

1. List 인터페이스를 구현한 구현체
2. List 인터페이스에서 리사이징 기능이 추가됨
3. 동기화가 되지 않는다.
4. 순차적인 접근법에 따라 대게 상수 시간의 연산속도를 가진다.

<br><br>

### Vector

---

Vector는 내부구조가 ArrayList와 거의 비슷하지만 동기화 된다는 특징이 있습니다. 자바 2 플랫폼 v1.2부터 벡터는 리스트 인터페이스를 
구현하기 위해 개조되어 컬렉션 프레임워크가 되었다고 합니다. Vector 클래스 내부 설명에 따르면 특수하게 Thread-Safe 환경이 아니라면
ArrayList를 사용하는 것을 권장합니다.

<br><br>

### LinkedList

---

LinkedList의 각 요소들은 다음 요소들의 참조값을 가지고 있다. 그러한 특징 때문에 데이터를 삭제 혹은 추가를 하게 되는 경우 이전 
ArrayList처럼 순환을 돌며 시행하지 않아도 되기 때문에 삭제나 추가에 강한 성능을 보인다.

하지만 데이터가 많아질 수록 무거워 지는 특성을
지녔다고 한다. 또한 LinkedList는 List와 Deque 인터페이스들을 이중으로 구현한다는 특징을 하지고 있다.

<br><br>

### Stack

---

마지막으로 자료구조에서 자주보던 Stack이다. Stack또한 자바의 컬렉션 프레임워크에서 구현이 되어있으며, 기존 특성처럼 LIFO(Last In First Out)의
특징을 가지고 있다. 기존 Vector을 상속받기 때문에 자연스럽게 안쓰인다고 한다. 더군다나 더욱 완벽한 LIFO 구조로 Deque가 존재하기 때문에
Deque를 사용하라고 권고 합니다.








